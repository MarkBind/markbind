import fs from 'fs';
import path from 'path';
import ignore from 'ignore';
import walkSync from 'walk-sync';
import { isBinary } from 'istextorbinary';
import isEqual from 'lodash/isEqual';
import intersection from 'lodash/intersection';
import { diffCharsAndPrint as diffChars } from './diffChars';

const _ = { isEqual, intersection };

// List of file patterns to ignore during content diff comparison.
// Either binary files or files not recognized correctly by the istextorbinary package.
// Note: Files ignored during content comparison, but existence of files still checked.
const TEST_BLACKLIST = ignore().add([
  '*.log',
  '*.woff',
  '*.woff2',
]);

const CRLF_REGEX = /\r\n/g;

function _readFileSync(...paths: string[]) {
  return fs.readFileSync(path.resolve(...paths));
}

/**
 * Filters out .page-vue-render.js files from the list of file paths.
 * @param {string[]} filePaths - List of file paths
 * @returns {string[]} Filtered list without *.page-vue-render.js files
 */
function filterPageVueRenderFiles(filePaths: string[]) {
  return filePaths.filter(p => !p.endsWith('.page-vue-render.js'));
}

/**
 * Gets directory structure as a sorted array of relative directory paths
 * @param {string} dirPath - Existing directory path to analyze
 * @returns {string[]} Sorted array of relative directory paths
 */
function getDirectoryStructure(dirPath: string) {
  const allPaths = walkSync(dirPath, { directories: true, globs: ['**/*'] });
  return allPaths
    .filter(p => fs.statSync(path.join(dirPath, p))
      .isDirectory())
    .map(p => p.replace(/\\/g, '/')) // Normalize path separators
    .sort();
}

/**
 * Compares files and optionally directories generated by the build process against the expected files.
 * Throws an error on:
 *   - Missing or extra files
 *   - Files differing in content
 *   - Ignored files not present
 * @param {string} root - Root path containing both expected and actual site folders
 * @param {string} expectedSiteRelativePath - Relative path to expected site output (default: "expected")
 * @param {string} siteRelativePath - Relative path to actual generated site output (default: "_site")
 * @param {string[]} ignoredPaths - Specify any paths to ignore for comparison, but still check for existence.
 * @param {boolean} compareDirectories - Whether to compare directory structures (default: false)
 */
function compare(root: string, expectedSiteRelativePath = 'expected', siteRelativePath = '_site',
                 ignoredPaths: string[] = [], compareDirectories = false) {
  const expectedDirectory = path.join(root, expectedSiteRelativePath);
  const actualDirectory = path.join(root, siteRelativePath);

  // Get directory structures if needed
  if (compareDirectories) {
    const expectedDirs = getDirectoryStructure(expectedDirectory);
    const actualDirs = getDirectoryStructure(actualDirectory);

    if (!_.isEqual(expectedDirs, actualDirs)) {
      throw new Error('Directory structures differ!'
        + `\nExpected: ${JSON.stringify(expectedDirs, null, 2)}`
        + `\nActual: ${JSON.stringify(actualDirs, null, 2)}`);
    }
  }

  let expectedPaths = walkSync(expectedDirectory, { directories: false });
  let actualPaths = walkSync(actualDirectory, { directories: false });

  // Vue render JS files (*.page-vue-render.js) are not committed to version control,
  // so we exclude them from the comparison to avoid false positive diffs.
  // Note: Every non-includes .html file has a corresponding js render binary file
  actualPaths = filterPageVueRenderFiles(actualPaths);
  expectedPaths = filterPageVueRenderFiles(expectedPaths);

  // Check for file existence of ignoredPaths and that they are present in actualPaths
  if (ignoredPaths.length !== 0 && !_.isEqual(_.intersection(ignoredPaths, actualPaths), ignoredPaths)) {
    throw new Error('Ignored paths are not present in actual paths!');
  }

  // Filter out ignoredPaths to avoid comparing them because they are binary files
  actualPaths = actualPaths.filter(p => !ignoredPaths.includes(p));
  expectedPaths = expectedPaths.filter(p => !ignoredPaths.includes(p));

  let error = false;
  if (expectedPaths.length !== actualPaths.length) {
    throw new Error('Unequal number of files! '
      + `Expected: ${expectedPaths.length}, Actual: ${actualPaths.length}`);
  }

  /* eslint-disable no-continue */
  for (let i = 0; i < expectedPaths.length; i += 1) {
    const expectedFilePath = expectedPaths[i];
    const actualFilePath = actualPaths[i];

    if (expectedFilePath !== actualFilePath) {
      throw new Error(`Different files built! Expected: ${expectedFilePath}, Actual: ${actualFilePath}`);
    }

    if (isBinary(expectedFilePath) || TEST_BLACKLIST.ignores(expectedFilePath)) {
      continue;
    }

    const expectedBuf = _readFileSync(expectedDirectory, expectedFilePath);
    if (isBinary(null, expectedBuf)) {
      // eslint-disable-next-line no-console
      console.warn(`Unrecognised file extension ${expectedFilePath} contains null characters, skipping`);
      continue;
    }

    // Get actual string content for comparison
    const expected = expectedBuf
      .toString('utf8')
      .replace(CRLF_REGEX, '\n');
    const actual = _readFileSync(actualDirectory, actualFilePath)
      .toString('utf8')
      .replace(CRLF_REGEX, '\n');

    const hasDiff = diffChars(expected, actual, expectedFilePath);
    error = error || hasDiff;
  }
  /* eslint-enable no-continue */

  if (error) {
    throw new Error('Diffs found in files');
  }
}

export {
  compare,
};
