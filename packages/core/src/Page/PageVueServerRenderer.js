const path = require('path');
const fs = require('fs-extra');

const Vue = require('vue');
const VueCompiler = require('vue-template-compiler');
const { renderToString } = require('vue-server-renderer').createRenderer();

let bundle = require('@markbind/core-web/dist/js/markbindvue.min');

const logger = require('../utils/logger');

/*
 * Suppress irrelevant Vue warnings that comes up during SSR.
 * These warnings are expected false-positives that do not affect the outcome of SSR.
 *
 * Following are some of the warnings in general form.
 * E.g. "Property or method is not defined on the instanced but referenced during render."
 * E.g. "'key' is a reserved attribute and cannot be used as component prop."
 * E.g. "Injection not found"
 * E.g. "Avoid mutating a prop directly since the value will be overwritten whenever the parent
 * component re-renders. Instead, use a data or computed property based on the prop's value."
 * E.g. "Invalid prop: type check failed for prop. Expected Number, got String."
 */
Vue.config.silent = true;

const pageEntries = {}; // hold the mapping of sourcePath to latest built pages (for hot-reload dev purposes)

let updateCount = 0;

/**
 * Compiles page into Vue Application to get the page render function and places
 * it into a script so that the browser can retrieve the page render function to
 * render the page during Vue mounting.
 *
 * This is to avoid the overhead of compiling the page into Vue application
 * on the client's browser (alleviates FOUC). It is also the pre-requisite to enable SSR.
 *
 * @param content Page content to be compiled into Vue app
 */
async function compileVuePageAndCreateScript(content, pageConfig, pageAsset) {
  // Compile Vue Page
  const compiled = VueCompiler.compileToFunctions(`<div id="app">${content}</div>`);

  // Set up script content
  const outputContent = `
    var pageVueRenderFn = ${compiled.render};
    var pageVueStaticRenderFns = [${compiled.staticRenderFns}];
  `;

  // Get script file name
  const pageHtmlFileName = path.basename(pageConfig.resultPath, '.html');
  const scriptFileName = `${pageHtmlFileName}.page-vue-render.js`;

  /*
   * Add the script file path for this page's render function to the page's assets (to populate page.njk).
   * The script file path is the same as the page's file path.
   */
  pageAsset.pageVueRenderJs = scriptFileName;

  // Get script's absolute file path to output script file
  const dirName = path.dirname(pageConfig.resultPath);
  const filePath = path.join(dirName, scriptFileName);

  await fs.outputFile(filePath, outputContent);
}

/**
 * Renders Vue page app into html string (Vue SSR).
 * This function will install the MarkBindVue plugin and render the built Vue page content into html string.
 */
async function renderVuePage(content) {
  /*
   * Each installation of plugin pollutes the global scope of Vue.
   * Thus, we use a fresh copy of Vue each time we install MarkBindVue to prevent the global pollution.
   * This prevents the old plugin from affecting the new plugin installation (in development mode).
   */
  const FreshVue = Vue.extend();
  FreshVue.use(bundle.MarkBindVue);

  const VueAppPage = new FreshVue({
    template: `<div id="app">${content}</div>`,
  });

  const renderedContent = await renderToString(VueAppPage);

  return renderedContent;
}

/**
 * Referenced from stackOverflow:
 * https://stackoverflow.com/questions/17581830/load-node-js-module-from-string-in-memory
 *
 * Credits to Dominic
 */
function requireFromString(src, filename) {
  const m = new module.constructor();
  m.paths = module.paths; // without this, we won't be able to require Vue in the string module
  m._compile(src, filename);
  return m.exports;
}

/**
 * Retrieves the latest updated MarkBindVue bundle from webpack compiler watcher,
 * re-render all the built pages, and output the page html files.
 * This function will only be used in development mode (for MarkBindVue bundle hot-reloading purposes).
 */
async function updateMarkBindVueBundle(newBundle) {
  logger.info(`CHANGES DETECTED IN MarkBindVue COMPONENTS: [Update Count - ${updateCount}]
Bundle is regenerated by webpack and built pages are re-rendered with the latest bundle. \n`);

  updateCount += 1;

  // reassign the latest updated MarkBindVue bundle
  bundle = requireFromString(newBundle, '');

  Object.values(pageEntries).forEach(async (pageEntry) => {
    const { page, builtPageContent, pageNav } = pageEntry;
    const renderedVuePageContent = await renderVuePage(builtPageContent);
    page.outputPageHtml(renderedVuePageContent, pageNav);
  });
}

const pageVueServerRenderer = {
  compileVuePageAndCreateScript,
  renderVuePage,
  updateMarkBindVueBundle,
  pageEntries,
};

module.exports = {
  pageVueServerRenderer,
};
