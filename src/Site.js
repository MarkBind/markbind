/* eslint-disable no-underscore-dangle */

const cheerio = require('cheerio');
const ejs = require('ejs');
const fs = require('fs-extra-promise');
const ghpages = require('gh-pages');
const ignore = require('ignore');
const nunjucks = require('nunjucks');
const path = require('path');
const Promise = require('bluebird');
const ProgressBar = require('progress');
const walkSync = require('walk-sync');

const _ = {};
_.union = require('lodash/union');
_.unionWith = require('lodash/unionWith');
_.uniq = require('lodash/uniq');

const url = {};
url.join = path.posix.join;

const delay = require('./util/delay');
const logger = require('./util/logger');
const Page = require('./Page');

const CLI_VERSION = require('../package.json').version;

const BOILERPLATE_FOLDER_NAME = '_markbind/boilerplates';
const CONFIG_FOLDER_NAME = '_markbind';
const HEADING_INDEXING_LEVEL_DEFAULT = 3;
const SITE_ASSET_FOLDER_NAME = 'asset';
const TEMP_FOLDER_NAME = '.temp';
const TEMPLATE_ROOT_FOLDER_NAME = 'template';
const TEMPLATE_SITE_ASSET_FOLDER_NAME = 'markbind';

const FAVICON_DEFAULT_PATH = 'favicon.ico';
const FONT_AWESOME_PATH = 'asset/font-awesome.csv';
const FOOTER_PATH = '_markbind/footers/footer.md';
const GLYPHICONS_PATH = 'asset/glyphicons.csv';
const HEAD_FOLDER_PATH = '_markbind/head';
const INDEX_MARKDOWN_FILE = 'index.md';
const PAGE_TEMPLATE_NAME = 'page.ejs';
const SITE_CONFIG_NAME = 'site.json';
const SITE_DATA_NAME = 'siteData.json';
const SITE_NAV_PATH = '_markbind/navigation/site-nav.md';
const LAYOUT_DEFAULT_NAME = 'default';
const LAYOUT_FILES = ['navigation.md', 'head.md', 'footer.md', 'styles.css', 'scripts.js'];
const LAYOUT_FOLDER_PATH = '_markbind/layouts';
const LAYOUT_SITE_FOLDER_NAME = 'layouts';
const USER_VARIABLES_PATH = '_markbind/variables.md';

const SITE_CONFIG_DEFAULT = {
  baseUrl: '',
  titlePrefix: '',
  ignore: [
    '_markbind/layouts/*',
    '_markbind/logs/*',
    '_site/*',
    'site.json',
    '*.md',
    '*.mbd',
    '.git/*',
  ],
  pages: [
    {
      src: 'index.md',
      title: 'Hello World',
    },
    {
      glob: '**/index.md',
    },
    {
      glob: '**/*.+(md|mbd)',
    },
  ],
  deploy: {
    message: 'Site Update.',
  },
};

const FOOTER_DEFAULT = '<footer>\n'
  + '  <div class="text-center">\n'
  + '    This is a dynamic height footer that supports variables {{glyphicon_tags}} '
  + 'and markdown <md>:smile:</md>!\n'
  + '  </div>\n'
  + '  <!-- Support MarkBind by including a link to us on your landing page! -->\n'
  + '  <div class="text-center">\n'
  + '    <small>[Generated by {{MarkBind}} on {{timestamp}}]</small>\n'
  + '  </div>\n'
  + '</footer>\n';

const INDEX_MARKDOWN_DEFAULT = '<frontmatter>\n'
  + '  title: "Hello World"\n'
  + '  footer: footer.md\n'
  + '  siteNav: site-nav.md\n'
  + '</frontmatter>\n\n'
  + '# Hello world\n'
  + 'Welcome to your page generated with MarkBind.\n';

const SITE_NAV_DEFAULT = '<navigation>\n'
  + '* [Home {{glyphicon_home}}]({{baseUrl}}/index.html)\n'
  + '</navigation>\n';

const USER_VARIABLES_DEFAULT = '<span id="example">\n'
  + 'To inject this HTML segment in your markbind files, use {{ example }} where you want to place it.\n'
  + 'More generally, surround the segment\'s id with double curly braces.\n'
  + '</span>';

const GENERATE_SITE_LOGGING_KEY = 'Generate Site';
const MARKBIND_WEBSITE_URL = 'https://markbind.github.io/markbind/';
const MARKBIND_LINK_HTML = `<a href='${MARKBIND_WEBSITE_URL}'>MarkBind ${CLI_VERSION}</a>`;

function Site(rootPath, outputPath, onePagePath, forceReload = false, siteConfigPath = SITE_CONFIG_NAME) {
  this.rootPath = rootPath;
  this.outputPath = outputPath;
  this.tempPath = path.join(rootPath, TEMP_FOLDER_NAME);

  // MarkBind assets to be copied
  this.siteAssetsSrcPath = path.resolve(__dirname, '..', SITE_ASSET_FOLDER_NAME);
  this.siteAssetsDestPath = path.join(outputPath, TEMPLATE_SITE_ASSET_FOLDER_NAME);

  // Page template path
  this.pageTemplatePath = path.join(__dirname, TEMPLATE_ROOT_FOLDER_NAME, PAGE_TEMPLATE_NAME);
  this.pageTemplate = ejs.compile(fs.readFileSync(this.pageTemplatePath, 'utf8'));
  this.pages = [];

  // Other properties
  this.addressablePages = [];
  this.baseUrlMap = {};
  this.forceReload = forceReload;
  this.onePagePath = onePagePath;
  this.siteConfig = {};
  this.siteConfigPath = siteConfigPath;
  this.userDefinedVariablesMap = {};
}

/**
 * Util Methods
 */

function rejectHandler(reject, error, removeFolders) {
  logger.warn(error);
  Promise.all(removeFolders.map(folder => fs.removeAsync(folder)))
    .then(() => {
      reject(error);
    })
    .catch((err) => {
      reject(new Error(`${error.message}\n${err.message}`));
    });
}

function getIconsMap() {
  const fontAwesomePath = path.join(__dirname, FONT_AWESOME_PATH);
  const glyphiconsPath = path.join(__dirname, GLYPHICONS_PATH);
  const fontAwesomeClasses = fs.readFileSync(fontAwesomePath, 'utf8').trimRight().split(/\r?\n/);
  const glyphiconsClasses = fs.readFileSync(glyphiconsPath, 'utf8').trimRight().split(/\r?\n/);
  const iconsMap = {};
  fontAwesomeClasses.forEach((fontAwesomeClass) => {
    const name = fontAwesomeClass.replace(' fa', '').replace(/-/g, '_');
    const html = `<span class='${fontAwesomeClass}'></span>`;
    iconsMap[name] = html;
  });
  glyphiconsClasses.forEach((glyphiconClass) => {
    const name = glyphiconClass.replace(/-/g, '_');
    const html = `<span class='glyphicon ${glyphiconClass}' aria-hidden='true'></span>`;
    iconsMap[name] = html;
  });
  return iconsMap;
}

function setExtension(filename, ext) {
  return path.join(
    path.dirname(filename),
    path.basename(filename, path.extname(filename)) + ext,
  );
}

/**
 * Static method for initializing a markbind site.
 * Generate the site.json and an index.md file.
 *
 * @param rootPath
 */
Site.initSite = function (rootPath) {
  const boilerplatePath = path.join(rootPath, BOILERPLATE_FOLDER_NAME);
  const configPath = path.join(rootPath, SITE_CONFIG_NAME);
  const footerPath = path.join(rootPath, FOOTER_PATH);
  const headFolderPath = path.join(rootPath, HEAD_FOLDER_PATH);
  const indexPath = path.join(rootPath, INDEX_MARKDOWN_FILE);
  const siteNavPath = path.join(rootPath, SITE_NAV_PATH);
  const siteLayoutPath = path.join(rootPath, LAYOUT_FOLDER_PATH);
  const siteLayoutDefaultPath = path.join(siteLayoutPath, LAYOUT_DEFAULT_NAME);
  const userDefinedVariablesPath = path.join(rootPath, USER_VARIABLES_PATH);
  // TODO: log the generate info
  return new Promise((resolve, reject) => {
    fs.accessAsync(boilerplatePath)
      .catch(() => {
        if (fs.existsSync(boilerplatePath)) {
          return Promise.resolve();
        }
        return fs.mkdirp(boilerplatePath);
      })
      .then(() => fs.accessAsync(configPath))
      .catch(() => {
        if (fs.existsSync(configPath)) {
          return Promise.resolve();
        }
        return fs.outputJsonAsync(configPath, SITE_CONFIG_DEFAULT);
      })
      .then(() => fs.accessAsync(indexPath))
      .catch(() => {
        if (fs.existsSync(indexPath)) {
          return Promise.resolve();
        }
        return fs.outputFileAsync(indexPath, INDEX_MARKDOWN_DEFAULT);
      })
      .then(() => fs.accessAsync(userDefinedVariablesPath))
      .catch(() => {
        if (fs.existsSync(userDefinedVariablesPath)) {
          return Promise.resolve();
        }
        return fs.outputFileAsync(userDefinedVariablesPath, USER_VARIABLES_DEFAULT);
      })
      .then(() => fs.accessAsync(footerPath))
      .catch(() => {
        if (fs.existsSync(footerPath)) {
          return Promise.resolve();
        }
        return fs.outputFileAsync(footerPath, FOOTER_DEFAULT);
      })
      .then(() => fs.accessAsync(headFolderPath))
      .catch(() => {
        if (fs.existsSync(headFolderPath)) {
          return Promise.resolve();
        }
        return fs.mkdirSync(headFolderPath);
      })
      .then(() => fs.accessAsync(siteNavPath))
      .catch(() => {
        if (fs.existsSync(siteNavPath)) {
          return Promise.resolve();
        }
        return fs.outputFileAsync(siteNavPath, SITE_NAV_DEFAULT);
      })
      .then(() => fs.accessAsync(siteLayoutPath))
      .catch(() => {
        if (fs.existsSync(siteLayoutPath)) {
          return Promise.resolve();
        }
        return fs.mkdirp(siteLayoutPath);
      })
      .then(() => fs.accessAsync(siteLayoutDefaultPath))
      .catch(() => {
        if (fs.existsSync(siteLayoutDefaultPath)) {
          return Promise.resolve();
        }
        return fs.mkdirp(siteLayoutDefaultPath);
      })
      .then(() => {
        LAYOUT_FILES.forEach((layoutFile) => {
          const layoutFilePath = path.join(siteLayoutDefaultPath, layoutFile);
          fs.accessAsync(layoutFilePath).catch(() => {
            if (fs.existsSync(layoutFilePath)) {
              return Promise.resolve();
            }
            return fs.outputFileAsync(layoutFilePath, '');
          });
        });
      })
      .then(resolve)
      .catch(reject);
  });
};

Site.prototype.readSiteConfig = function (baseUrl) {
  return new Promise((resolve, reject) => {
    const siteConfigPath = path.join(this.rootPath, this.siteConfigPath);
    fs.readJsonAsync(siteConfigPath)
      .then((config) => {
        this.siteConfig = config;
        this.siteConfig.baseUrl = (baseUrl === undefined) ? this.siteConfig.baseUrl : baseUrl;
        this.siteConfig.enableSearch = (config.enableSearch === undefined) || config.enableSearch;
        resolve(this.siteConfig);
      })
      .catch((err) => {
        reject(new Error(`Failed to read the site config file '${this.siteConfigPath}' at`
          + `${this.rootPath}:\n${err.message}\nPlease ensure the file exist or is valid`));
      });
  });
};

Site.prototype.listAssets = function (fileIgnore) {
  return new Promise((resolve, reject) => {
    let files;
    try {
      files = walkSync(this.rootPath, { directories: false });
      resolve(fileIgnore.filter(files));
    } catch (error) {
      reject(error);
    }
  });
};

Site.prototype.createPage = function (config) {
  const sourcePath = path.join(this.rootPath, config.pageSrc);
  const tempPath = path.join(this.tempPath, config.pageSrc);
  const resultPath = path.join(this.outputPath, setExtension(config.pageSrc, '.html'));
  return new Page({
    baseUrl: this.siteConfig.baseUrl,
    baseUrlMap: this.baseUrlMap,
    content: '',
    faviconUrl: config.faviconUrl,
    tags: this.siteConfig.tags,
    pageTemplate: this.pageTemplate,
    rootPath: this.rootPath,
    searchable: this.siteConfig.enableSearch && config.searchable,
    src: config.pageSrc,
    layoutsAssetPath: path.relative(path.dirname(resultPath),
                                    path.join(this.siteAssetsDestPath, LAYOUT_SITE_FOLDER_NAME)),
    layout: config.layout,
    title: config.title || '',
    titlePrefix: this.siteConfig.titlePrefix,
    headingIndexingLevel: this.siteConfig.headingIndexingLevel || HEADING_INDEXING_LEVEL_DEFAULT,
    userDefinedVariablesMap: this.userDefinedVariablesMap,
    sourcePath,
    tempPath,
    resultPath,
    asset: {
      bootstrap: path.relative(path.dirname(resultPath),
                               path.join(this.siteAssetsDestPath, 'css', 'bootstrap.min.css')),
      bootstrapVue: path.relative(path.dirname(resultPath),
                                  path.join(this.siteAssetsDestPath, 'css', 'bootstrap-vue.min.css')),
      externalScripts: _.union(this.siteConfig.externalScripts, config.externalScripts),
      fontAwesome: path.relative(path.dirname(resultPath),
                                 path.join(this.siteAssetsDestPath, 'css', 'font-awesome.min.css')),
      glyphicons: path.relative(path.dirname(resultPath),
                                path.join(this.siteAssetsDestPath, 'css', 'bootstrap-glyphicons.min.css')),
      highlight: path.relative(path.dirname(resultPath),
                               path.join(this.siteAssetsDestPath, 'css', 'github.min.css')),
      markbind: path.relative(path.dirname(resultPath),
                              path.join(this.siteAssetsDestPath, 'css', 'markbind.css')),
      pageNavCss: path.relative(path.dirname(resultPath),
                                path.join(this.siteAssetsDestPath, 'css', 'page-nav.css')),
      siteNavCss: path.relative(path.dirname(resultPath),
                                path.join(this.siteAssetsDestPath, 'css', 'site-nav.css')),
      bootstrapUtilityJs: path.relative(path.dirname(resultPath),
                                        path.join(this.siteAssetsDestPath, 'js', 'bootstrap-utility.min.js')),
      bootstrapVueJs: path.relative(path.dirname(resultPath),
                                    path.join(this.siteAssetsDestPath, 'js', 'bootstrap-vue.min.js')),
      polyfillJs: path.relative(path.dirname(resultPath),
                                path.join(this.siteAssetsDestPath, 'js', 'polyfill.min.js')),
      setup: path.relative(path.dirname(resultPath),
                           path.join(this.siteAssetsDestPath, 'js', 'setup.js')),
      vue: path.relative(path.dirname(resultPath),
                         path.join(this.siteAssetsDestPath, 'js', 'vue.min.js')),
      vueStrap: path.relative(path.dirname(resultPath),
                              path.join(this.siteAssetsDestPath, 'js', 'vue-strap.min.js')),
    },
  });
};


/**
 * Collects the paths to be traversed as addressable pages
 */
Site.prototype.collectAddressablePages = function () {
  const { pages } = this.siteConfig;
  const addressableGlobs = pages.filter(page => page.glob);
  this.addressablePages = pages.filter(page => page.src);
  const globPaths = addressableGlobs.reduce((globPages, addressableGlob) =>
    globPages.concat(walkSync(this.rootPath, {
      directories: false,
      globs: [addressableGlob.glob],
      ignore: [CONFIG_FOLDER_NAME],
    }).map(globPath => ({
      src: globPath,
      searchable: addressableGlob.searchable,
      layout: addressableGlob.layout,
    }))), []);
  // Add pages collected by walkSync without duplication
  this.addressablePages = _.unionWith(this.addressablePages, globPaths,
                                      ((pageA, pageB) => pageA.src === pageB.src));
};

Site.prototype.collectBaseUrl = function () {
  const candidates
    = walkSync(this.rootPath, { directories: false })
      .filter(x => x.endsWith(this.siteConfigPath))
      .map(x => path.resolve(this.rootPath, x));

  this.baseUrlMap = candidates.reduce((pre, now) => {
    // eslint-disable-next-line no-param-reassign
    pre[path.dirname(now)] = true;
    return pre;
  }, {});

  return Promise.resolve();
};

/**
 * Collects the user defined variables map in the site/subsites
 */
Site.prototype.collectUserDefinedVariablesMap = function () {
  // The key is the base directory of the site/subsites,
  // while the value is a mapping of user defined variables
  this.userDefinedVariablesMap = {};
  const iconsMap = getIconsMap();
  const markbindVariable = { MarkBind: MARKBIND_LINK_HTML };

  Object.keys(this.baseUrlMap).forEach((base) => {
    const userDefinedVariables = {};
    Object.assign(userDefinedVariables, iconsMap, markbindVariable);

    let content;
    try {
      const userDefinedVariablesPath = path.resolve(base, USER_VARIABLES_PATH);
      content = fs.readFileSync(userDefinedVariablesPath, 'utf8');
    } catch (e) {
      content = '';
      logger.warn(e.message);
    }

    // This is to prevent the first nunjuck call from converting {{baseUrl}} to an empty string
    // and let the baseUrl value be injected later.
    userDefinedVariables.baseUrl = '{{baseUrl}}';
    this.userDefinedVariablesMap[base] = userDefinedVariables;

    const $ = cheerio.load(content);
    $.root().children().each(function () {
      const id = $(this).attr('id');
      // Process the content of the variable with nunjucks, in case it refers to other variables.
      const html = nunjucks.renderString($(this).html(), userDefinedVariables);
      userDefinedVariables[id] = html;
    });
  });
};

/**
 * Collects the user defined variables map in the site/subsites
 * if there is a change in the variables file
 * @param filePaths array of paths corresponding to files that have changed
 */
Site.prototype.collectUserDefinedVariablesMapIfNeeded = function (filePaths) {
  const variablesPath = path.resolve(this.rootPath, USER_VARIABLES_PATH);
  if (filePaths.includes(variablesPath)) {
    this.collectUserDefinedVariablesMap();
    return true;
  }
  return false;
};

Site.prototype.generate = function (baseUrl) {
  const startTime = new Date();
  // Create the .tmp folder for storing intermediate results.
  logger.profile(GENERATE_SITE_LOGGING_KEY);
  fs.emptydirSync(this.tempPath);
  // Clean the output folder; create it if not exist.
  fs.emptydirSync(this.outputPath);
  logger.info(`Website generation started at ${startTime.toLocaleTimeString()}`);
  return new Promise((resolve, reject) => {
    this.readSiteConfig(baseUrl)
      .then(() => this.collectAddressablePages())
      .then(() => this.collectBaseUrl())
      .then(() => this.collectUserDefinedVariablesMap())
      .then(() => this.buildAssets())
      .then(() => this.buildSourceFiles())
      .then(() => this.copyMarkBindAsset())
      .then(() => this.copyLayouts())
      .then(() => this.updateSiteData())
      .then(() => {
        const endTime = new Date();
        const totalBuildTime = (endTime - startTime) / 1000;
        logger.info(`Website generation complete! Total build time: ${totalBuildTime}s`);
      })
      .then(resolve)
      .catch((error) => {
        rejectHandler(reject, error, [this.tempPath, this.outputPath]);
      })
      .finally(() => logger.profile(GENERATE_SITE_LOGGING_KEY));
  });
};

/**
 * Build all pages of the site
 */
Site.prototype.buildSourceFiles = function () {
  return new Promise((resolve, reject) => {
    logger.info('Generating pages...');
    this.generatePages()
      .then(() => fs.removeAsync(this.tempPath))
      .then(() => logger.info('Pages built'))
      .then(resolve)
      .catch((error) => {
        // if error, remove the site and temp folders
        rejectHandler(reject, error, [this.tempPath, this.outputPath]);
      });
  });
};

Site.prototype._rebuildAffectedSourceFiles = function (filePaths) {
  const filePathArray = Array.isArray(filePaths) ? filePaths : [filePaths];
  const uniquePaths = _.uniq(filePathArray);
  logger.verbose(`Rebuild affected paths: ${uniquePaths}`);
  return new Promise((resolve, reject) => {
    this.regenerateAffectedPages(uniquePaths)
      .then(() => fs.removeAsync(this.tempPath))
      .then(resolve)
      .catch((error) => {
        // if error, remove the site and temp folders
        rejectHandler(reject, error, [this.tempPath, this.outputPath]);
      });
  });
};

/**
 * Rebuild pages that are affected by changes in filePaths
 * @param filePaths a single path or an array of paths corresponding to the files that have changed
 */
Site.prototype.rebuildAffectedSourceFiles
  = delay(Site.prototype._rebuildAffectedSourceFiles, 1000);

Site.prototype._buildMultipleAssets = function (filePaths) {
  const filePathArray = Array.isArray(filePaths) ? filePaths : [filePaths];
  const uniquePaths = _.uniq(filePathArray);
  const ignoreConfig = this.siteConfig.ignore || [];
  const fileIgnore = ignore().add(ignoreConfig);
  const fileRelativePaths = uniquePaths.map(filePath => path.relative(this.rootPath, filePath));
  const copyAssets = fileIgnore.filter(fileRelativePaths)
    .map(asset => fs.copyAsync(path.join(this.rootPath, asset), path.join(this.outputPath, asset)));
  return Promise.all(copyAssets)
    .then(() => logger.info('Assets built'));
};

/**
 * Build/copy assets that are specified in filePaths
 * @param filePaths a single path or an array of paths corresponding to the assets to build
 */
Site.prototype.buildAsset
 = delay(Site.prototype._buildMultipleAssets, 1000);

Site.prototype._removeMultipleAssets = function (filePaths) {
  const filePathArray = Array.isArray(filePaths) ? filePaths : [filePaths];
  const uniquePaths = _.uniq(filePathArray);
  const fileRelativePaths = uniquePaths.map(filePath => path.relative(this.rootPath, filePath));
  const filesToRemove = fileRelativePaths.map(
    fileRelativePath => path.join(this.outputPath, fileRelativePath));
  const removeFiles = filesToRemove.map(asset => fs.removeAsync(asset));
  return Promise.all(removeFiles)
    .then(() => logger.info('Assets removed'));
};

/**
 * Remove assets that are specified in filePaths
 * @param filePaths a single path or an array of paths corresponding to the assets to remove
 */
Site.prototype.removeAsset
 = delay(Site.prototype._removeMultipleAssets, 1000);

Site.prototype.buildAssets = function () {
  logger.info('Building assets...');
  return new Promise((resolve, reject) => {
    const ignoreConfig = this.siteConfig.ignore || [];
    const outputFolder = path.relative(this.rootPath, this.outputPath);
    ignoreConfig.push(outputFolder); // ignore generated site folder
    const fileIgnore = ignore().add(ignoreConfig);
    // Scan and copy assets (excluding ignore files).
    this.listAssets(fileIgnore)
      .then(assets =>
        assets.map(asset => fs.copyAsync(path.join(this.rootPath, asset), path.join(this.outputPath, asset))),
      )
      .then(copyAssets => Promise.all(copyAssets))
      .then(() => logger.info('Assets built'))
      .then(resolve)
      .catch((error) => {
        rejectHandler(reject, error, []); // assets won't affect deletion
      });
  });
};

/**
 * Renders all pages specified in site configuration file to the output folder
 */
Site.prototype.generatePages = function () {
  // Run MarkBind include and render on each source file.
  // Render the final rendered page to the output folder.
  const { baseUrl, faviconPath } = this.siteConfig;
  const addressablePages = this.addressablePages || [];
  const builtFiles = {};
  const processingFiles = [];

  let faviconUrl;
  if (faviconPath) {
    faviconUrl = url.join('/', baseUrl, faviconPath);
    if (!fs.existsSync(path.join(this.rootPath, faviconPath))) {
      logger.warn(`${faviconPath} does not exist`);
    }
  } else if (fs.existsSync(path.join(this.rootPath, FAVICON_DEFAULT_PATH))) {
    faviconUrl = url.join('/', baseUrl, FAVICON_DEFAULT_PATH);
  }

  this._setTimestampVariable();
  if (this.onePagePath) {
    const page = addressablePages.find(p => p.src === this.onePagePath);
    if (!page) {
      return Promise.reject(new Error(`${this.onePagePath} is not specified in the site configuration.`));
    }
    this.pages.push(this.createPage({
      faviconUrl,
      pageSrc: page.src,
      title: page.title,
      layout: page.layout,
      searchable: page.searchable !== 'no',
      externalScripts: page.externalScripts,
    }));
  } else {
    this.pages = addressablePages.map(page => this.createPage({
      faviconUrl,
      pageSrc: page.src,
      title: page.title,
      layout: page.layout,
      searchable: page.searchable !== 'no',
      externalScripts: page.externalScripts,
    }));
  }

  const progressBar = new ProgressBar(`[:bar] :current / ${this.pages.length} pages built`,
                                      { total: this.pages.length });
  progressBar.render();
  this.pages.forEach((page) => {
    processingFiles.push(page.generate(builtFiles)
      .then(() => progressBar.tick())
      .catch((err) => {
        logger.error(err);
        return Promise.reject(new Error(`Error while generating ${page.sourcePath}`));
      }));
  });
  return new Promise((resolve, reject) => {
    Promise.all(processingFiles)
      .then(resolve)
      .catch(reject);
  });
};

/**
 * Re-renders pages that contain the original file path
 * as the source file or as a static/dynamic included file
 * @param filePaths array of paths corresponding to files that have changed
 */
Site.prototype.regenerateAffectedPages = function (filePaths) {
  const builtFiles = {};
  const processingFiles = [];
  const shouldRebuildAllPages = this.collectUserDefinedVariablesMapIfNeeded(filePaths) || this.forceReload;
  if (shouldRebuildAllPages) {
    logger.warn('Rebuilding all pages as variables file was changed, or the --force-reload flag was set');
  }
  this._setTimestampVariable();
  this.pages.forEach((page) => {
    if (shouldRebuildAllPages || filePaths.some(filePath => page.includedFiles[filePath])) {
      // eslint-disable-next-line no-param-reassign
      page.userDefinedVariablesMap = this.userDefinedVariablesMap;
      processingFiles.push(page.generate(builtFiles)
        .catch((err) => {
          logger.error(err);
          return Promise.reject(new Error(`Error while generating ${page.sourcePath}`));
        }));
    }
  });

  logger.info(`Rebuilding ${processingFiles.length} pages`);

  return new Promise((resolve, reject) => {
    Promise.all(processingFiles)
      .then(() => this.updateSiteData(shouldRebuildAllPages ? undefined : filePaths))
      .then(() => logger.info('Pages rebuilt'))
      .then(resolve)
      .catch(reject);
  });
};


/**
 * Uses heading data in built pages to generate heading and keyword information for siteData
 * Subsequently writes to siteData.json
 * @param filePaths optional array of updated file paths during live preview.
 *                  If undefined, generate site data for all pages
 */
Site.prototype.updateSiteData = function (filePaths) {
  const generateForAllPages = filePaths === undefined;
  this.pages.forEach((page) => {
    if (generateForAllPages || filePaths.some(filePath => page.includedFiles[filePath])) {
      page.collectHeadingsAndKeywords();
      page.concatenateHeadingsAndKeywords();
    }
  });
  this.writeSiteData();
};

Site.prototype.copyMarkBindAsset = function () {
  return new Promise((resolve, reject) => {
    fs.copyAsync(this.siteAssetsSrcPath, this.siteAssetsDestPath)
      .then(resolve)
      .catch(reject);
  });
};

/**
 * Copies layouts to the assets folder
 */
Site.prototype.copyLayouts = function () {
  const siteLayoutPath = path.join(this.rootPath, LAYOUT_FOLDER_PATH);
  const layoutsDestPath = path.join(this.siteAssetsDestPath, LAYOUT_SITE_FOLDER_NAME);
  if (!fs.existsSync(siteLayoutPath)) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    fs.copyAsync(siteLayoutPath, layoutsDestPath)
      .then(resolve)
      .catch(reject);
  });
};

/**
 * Writes the site data to a file
 */
Site.prototype.writeSiteData = function () {
  return new Promise((resolve, reject) => {
    const siteDataPath = path.join(this.outputPath, SITE_DATA_NAME);
    const siteData = {
      enableSearch: this.siteConfig.enableSearch,
      pages: this.pages.filter(page => page.searchable)
        .map(page => Object.assign({ headings: page.headings }, page.frontMatter)),
    };

    fs.outputJsonAsync(siteDataPath, siteData)
      .then(() => logger.info('Site data built'))
      .then(resolve)
      .catch((error) => {
        rejectHandler(reject, error, [this.tempPath, this.outputPath]);
      });
  });
};

Site.prototype.deploy = function () {
  const defaultDeployConfig = {
    branch: 'gh-pages',
    message: 'Site Update.',
    repo: '',
  };
  process.env.NODE_DEBUG = 'gh-pages';
  return new Promise((resolve, reject) => {
    const publish = Promise.promisify(ghpages.publish);
    this.readSiteConfig()
      .then(() => {
        this.siteConfig.deploy = this.siteConfig.deploy || {};
        const basePath = this.siteConfig.deploy.baseDir || this.outputPath;
        if (!fs.existsSync(basePath)) {
          reject(new Error('The site directory does not exist. Please build the site first before deploy.'));
          return undefined;
        }
        const options = {};
        options.branch = this.siteConfig.deploy.branch || defaultDeployConfig.branch;
        options.message = this.siteConfig.deploy.message || defaultDeployConfig.message;
        options.repo = this.siteConfig.deploy.repo || defaultDeployConfig.repo;
        return publish(basePath, options);
      })
      .then(resolve)
      .catch(reject);
  });
};

// eslint-disable-next-line no-underscore-dangle
Site.prototype._setTimestampVariable = function () {
  const time = new Date().toUTCString();
  Object.keys(this.userDefinedVariablesMap).forEach((base) => {
    this.userDefinedVariablesMap[base].timestamp = time;
  });
  return Promise.resolve();
};

module.exports = Site;
